/*
Пояснение алгоритма CYK:
Цель: Проверить, принадлежит ли строка языку, заданному КС-грамматикой в нормальной форме Хомского (НФХ).

Сложность:
Время: O(n^3 * |G|), где n — длина строки, G - грамматика.
  Три вложенных цикла: по длине подстрок, по начальной позиции, по точкам разбиения.
Память: O(n^2) для хранения таблицы.

Этапы:
Инициализация:
  Для каждого символа строки заполняются ячейки таблицы для подстрок длины 1.
Заполнение таблицы:
  Для подстрок большей длины перебираются все возможные разбиения и комбинации правил вида A → B C.
Проверка результата:
  Если стартовый символ грамматики присутствует в ячейке table[0][n], строка выводима.
Восстановление вывода:
  Рекурсивный обход таблицы для построения последовательности примененных правил.
*/

#include <iostream>
#include "grammar.h"
#include "cyk.h"

using namespace std;

int main(int argc, char *argv[])
{
  if (argc < 2)
  {
    cerr << "Использование: " << argv[0] << " <файл_грамматики>\n";
    return 1;
  }

  // Загрузка грамматики
  if (!read_grammar(argv[1]))
  {
    cerr << "Ошибка чтения файла грамматики!\n";
    return 1;
  }

  // Ввод слов для проверки
  char word[256];
  while (true)
  {
    cout << "Введите слово: ";
    if (!(cin >> word))
      break; // Выход при EOF (Ctrl+D/Z)

    StringArray derivation; // Список шагов вывода
    if (cyk(word, derivation))
    {
      cout << "Слово выводимо! Шаги:\n";
      for (int i = 0; i < derivation.size; ++i)
      {
        cout << derivation.data[i] << '\n';
      }
    }
    else
    {
      cout << "Слово не выводимо.\n";
    }
  }

  return 0;
}